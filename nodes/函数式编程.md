
<!-- TOC -->

- [为什么要学习函数编程以及什么是函数式编程](#为什么要学习函数编程以及什么是函数式编程)
- [函数式编程的特性（纯函数、柯里化、函数组合等）](#函数式编程的特性纯函数柯里化函数组合等)
- [函数式编程的应用场景](#函数式编程的应用场景)
- [函数式编程库Lodash](#函数式编程库lodash)

<!-- /TOC -->

###为什么要学习函数编程以及什么是函数式编程
    为什么要学：
        函数式编程是非常古老的一个概念，早于第一台计算机的诞生，函数式编程的历史。

        那我们为什么现在还要学函数式编程？

            * 函数式编程是随着react的流行收到越来越多的关注
            * Vue 3也开始拥抱函数式编程
            * 函数式编程可以抛弃this
            * 打包过程中可以更好的利用tree shaking 过滤无用代码
            * 方便测试，方便并行处理
            * 有很多库可以帮助我们进行函数式开发： lodash、 underscore、 ramda

    函数式编程概念：
        什么是函数式编程？
        函数式编程（Functional Programming，FP），FP是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程。

        * 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装，继承和多态来演示事物事件的联系
        * 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）
            * 程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数
            * x-> f(联系、映射) ->y, y=f(x)
            * 函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系，例如：**y=sin(X)**,x和y的关系
            *相同的输入始终要得到相同的输出（纯函数）
            *函数式编程用来描述数据（函数）之间的映射

        //非函数
        let num1 = 2
        let num2 = 3
        let sum = num1 + num2
        console.log(sum)
        

        //函数式
        function add(n1, n2){
            return n1 + n2
        }
        let sum = add(2, 3)
        console.log(sum)
    函数是一等公民：
        1、函数可以存储在变量中
        2、函数作为参数
        3、函数作为返回值

        在JavaScript中函数就是一个普通的对象（可以通过 new Function（）），我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 new Function（'alert(1)'）来构造一个新的函数。

            *把函数赋值给变量

    高阶函数：
        高阶函数（Heigher-order function）
            可以把函数作为参数传递给另一个函数
            可以把函数作为另一个函数的返回结果
           

###函数式编程的特性（纯函数、柯里化、函数组合等）
    纯函数：（Pure functions）
        概念：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
            * 纯函数就类似数学中的函数（用来描述输入和输出之间的关系），y = f(x)
            * lodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法
            * 数组的slice和splice分别是：纯函数和不纯函数
                * slice 返回数组中的指定部分，不会改变原数组
                * splice 对数组进行操作返回该数组，会改变原数组
            * 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）
            * 我们可以把一个函数的执行结果交给另一个函数去处理

    Lodash:
        https://lodash.com
        https://github.com/lodash/lodash/wiki/FP-Guide
        npm init -y
        npm i lodash

    纯函数的好处：
        可缓存
            * 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来
            * 自己模拟一个memoize函数

            * 可测试
                * 纯函数让测试更方便
            * 并行处理
                * 在多线程环境下并行操作共享的内存数据很可能会出现意外
                * 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）

    函数的副作用：
        * 纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

        副作用让一个函数变得不存（如上例）， 纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。

        副作用来源：
            配置文件
            数据库
            获取用户的输入
            。。。
        所有的外部交互都有可能代理副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

    柯里化（Haskell BrooksCurry）
        * 使用柯里化解决上一个案例中硬编码的问题
        let checkAge = min =>（age => age>= min）

        * 柯里化（Currying）
            当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
            然后返回一个新的函数接收剩余的参数，返回结果

    Lodash中的柯里化方法：
        lodash中的柯里化函数
            * _.curry(fun)
                * 功能：创建一个函数，该函数接收一个或多个func的参数，如果func所需要的参数都被提供则执行func并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。
                * 参数：需要柯里化的函数
                * 返回值：柯里化后的函数


    柯里化案例：

    柯里化总结：
        柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
        这是一种对函数参数的‘缓存’
        让函数变得更灵活，让函数的粒度更小
        可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

    函数组合：
        纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))
            获取数组的最后一个元素再转换成大写字母， _.toUpper(_.first(_.reverse(array)))
            函数组合可以让我们把细粒度的函数重新组合生成一个新的函数

        管道
        函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
            函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
            函数组合默认是从右到左执行


###函数式编程的应用场景


###函数式编程库Lodash
    Lodash中的组合函数
        lodash中组合函数flow()或者flowRight()，他们都可以组合多个函数
        flow()从左到右运行
        flowRight()从右到左运行，使用的更多一些


    函数的组合要满足结合律（associativity）
        我们既可以把g和h组合，还可以把f和g组合，结果都是一样的

    Lodash中的FP模块
        Lodash中的FP模块提供了实用的对函数式编程友好的方法
        提供了不可变auto-curried iteratee-firsh data-last 方法

    Lodash-map中的FP模块
        lodash中返回3个，lodash-fp 返回一个

    Pointfree
        我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

        不需要指明处理的数据
        只需要合成运算过程
        需要定义一些基本运算函数

    Functor（函子）
        为什么要学函子
            到目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等

        什么是functor
            容器：包含值和值的变形关系（这个变形关系就是函数）
            函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）
        Functor总结
        函数式编程的运算不直接操作值，而是由函子完成
        函子就是一个实现map契约的对象
        我们可以把函子想象成一个盒子，这个盒子里封装了一个值
        想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
        最终map方法返回一个包含新值的盒子（函子）


    MayBe函子
        我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理
        MayBe函子的作用就是可以对外部的空值做处理（控制副作用在允许的范围）

    Either函子
        Either两者中的任何一个，类似于if...else...的处理
        异常会让函数变的不纯，Either函子可以用来做异常处理

    IO函子
        IO函子中的_value是一个函数，这里是把函数作为值来处理
        IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作是纯的操作
        把不纯的操作交给调用者来处理

    npm init -y
    npm i lodash

    folktale
        Task异步执行
            异步任务的实现过于复杂，我们使用folktale中的Task来演示
            folktask一个标准的函数式编程库
                和lodash、ramda不同的是，它没有提供很多功能呢函数
                只提供了一些函数式处理的操作，例如：compose、curry等，一些函子Task、Either、MayBe等
            folktale(2.3.2)2.x中的Task和1.0中Task区别很大，1.0中的用法更接近我们现在演示的函子
            这里以2.3.2来演示
            
            npm i folktale

    Pointed函子
        Pointed函子是实现了of静态方法的函子
        of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context（把值放到容器中，使用map来处理值）

    Monad（单子）
        值使用IO函子的时候

    Monad函子
        Monad函子是可以变扁的Pointed函子，IO（IO(X)）
        一个函子如果具有join和of两个方法并遵守一些定律就是一个Monad

        [当一个函数返回一个函子的时候，要想到使用Monad，Monad可以帮我们解决函子嵌套的问题；当我们想要合并一个函数，并且函数返回一个值，我们可以调用map方法；当我们想要合并一个函数，但是这个函数返回一个函子，用flatMap方法 ]
        [函数嵌套使用函数组合，函子嵌套使用Monad]

    总结：